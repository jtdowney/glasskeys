import gbor.{CBInt, CBMap, CBString}
import glasskeys.{InvalidAttestation, UnsupportedFeature, UnsupportedKey}
import glasskeys/internal
import gleam/bit_array

fn rs256_cose_key_cbor() -> BitArray {
  let x = <<
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
    0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a,
    0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
  >>
  let y = <<
    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
    0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,
    0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
  >>
  bit_array.concat([
    <<0xa5, 0x01, 0x02, 0x03, 0x39, 0x01, 0x00, 0x20, 0x01, 0x21, 0x58, 0x20>>,
    x,
    <<0x22, 0x58, 0x20>>,
    y,
  ])
}

fn p384_cose_key_cbor() -> BitArray {
  let x = <<
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
    0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a,
    0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
  >>
  let y = <<
    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
    0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,
    0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
  >>
  bit_array.concat([
    <<0xa5, 0x01, 0x02, 0x03, 0x26, 0x20, 0x02, 0x21, 0x58, 0x20>>,
    x,
    <<0x22, 0x58, 0x20>>,
    y,
  ])
}

fn short_key_cose_key_cbor() -> BitArray {
  let x = <<
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
    0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a,
    0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  >>
  let y = <<
    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
    0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,
    0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
  >>
  bit_array.concat([
    <<0xa5, 0x01, 0x02, 0x03, 0x26, 0x20, 0x01, 0x21, 0x58, 0x1f>>,
    x,
    <<0x22, 0x58, 0x20>>,
    y,
  ])
}

pub fn rejects_unsupported_algorithm_test() {
  let result = internal.parse_public_key(rs256_cose_key_cbor())
  let assert Error(UnsupportedKey(_)) = result
}

pub fn rejects_unsupported_curve_test() {
  let result = internal.parse_public_key(p384_cose_key_cbor())
  let assert Error(UnsupportedKey(_)) = result
}

pub fn rejects_invalid_key_size_test() {
  let result = internal.parse_public_key(short_key_cose_key_cbor())
  let assert Error(UnsupportedKey(_)) = result
}

pub fn rejects_extensions_test() {
  let rp_id_hash = <<
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c,
    0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  >>
  let flags = <<0x81>>
  let sign_count = <<0x00, 0x00, 0x00, 0x01>>
  let auth_data = bit_array.concat([rp_id_hash, flags, sign_count])
  let result = internal.parse_authenticator_data(auth_data)
  let assert Error(UnsupportedFeature(_)) = result
}

pub fn none_attestation_requires_empty_map_test() {
  let non_empty_map = CBMap([#(CBString("extra"), CBInt(1))])
  let result = internal.verify_attestation("none", non_empty_map)
  let assert Error(InvalidAttestation(_)) = result
}
